<!doctype html>
<html lang="en">
<head>
	<meta name="generator" content="Hugo 0.54.0" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0">
  <title>CJ&#39;s Blog - CJ's Blog</title>
  <meta name="author" content="CJ">
  <meta name="description" content="CJ&#39;s Blog">
  <meta charset="utf-8" />
  <link rel="stylesheet" href="/asset/main.css">
  <link rel="stylesheet" type="text/css" href="/gitalk.css">
  <script src="/gitalk.min.js"></script>
  <script type="text/javascript">
    window.PAGE = {
      title: "CJ\x27s Blog",
    }
  </script>
</head>
<body>
  
    <header class="header">
  <a href="/">
    <img class="header__avatar" src="/image/avatar.jpeg">
  </a>

  <nav class="header__nav">
    <a href="/" class="header__nav__item  header__nav__item--active ">Posts</a>

    <a href="/archive" class="header__nav__item ">Archive</a>

    <a href="https://github.com/fate-lovely" class="header__nav__item" target="_blank">Github</a>

    <a href="/about" class="header__nav__item">About</a>
  </nav>
</header>

    <main class="main">
      
        <nav class="sidebar">
  
  
    <a class="sidebar__item " href="/web2.0/">Web2.0</a>
  
    <a class="sidebar__item " href="/go/">Go</a>
  
    <a class="sidebar__item " href="/linux/">Linux</a>
  
    <a class="sidebar__item " href="/mac/">Mac</a>
  
    <a class="sidebar__item " href="/misc/">MISC</a>
  
</nav>

        <div class="container">
          
  <div class="index">
    
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/11/07/make-loading-animation-with-svg-morphing/">
          使用 SVG Morphing 制作自己的加载动画
        </a>

        <div class="index__item__content post__content">
          <p>每一个需要让用户等待的应用都应该有加载界面，可以是简单的文本，比如 <code>加载中…</code>，也可以是有趣的动画。当然，一个好玩的加载动画能够大大增加用户等待的耐心，谁喜欢枯燥的文字呢。所以，投入点时间寻找或者制作一个加载动画是很有意义的。感谢 SVG 和相关的动画技术，现在制作一款复杂的动画已经变得十分容易了。</p>

<p>这里我使用 SVG 的形变技术（Shape Morphing）来做一个简单的矩形、三角形、圆形变换的动画。</p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.11.07
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/10/21/build-log-system-with-elkb/">
          从零开始搭建一个 ELKB 日志收集系统
        </a>

        <div class="index__item__content post__content">
          <p>当今的软件开发 <strong>多核</strong> 以及 <strong>分布</strong> 已经成为了常态，基本上稍大型的应用都是多台机器分布式部署。分布式在提高性能的同时也带来了很多问题，今天我们只讨论一点，那就是如何处理多台机器线上系统的日志。</p>

<p>以我司的某个应用 T 为例，部署在了百度云 5 台机子上，其中一台拥有公网 IP，使用了百度云提供的负载均衡服务。每次想要在日志中检索某个关键字时，基本步骤如下：</p>

<ul>
<li>打开五个 SSH，登陆拥有公网 IP 的那台机器</li>
<li>在另外四个 SSH 中分别登陆其他的内网机器</li>
<li>对日志文件进行检索</li>
</ul>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.10.21
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/09/05/build-a-https-site-from-scratch/">
          从零开始搭建一个 HTTPS 网站
        </a>

        <div class="index__item__content post__content">
          <p>我们都知道 HTTP 是非常不安全的，不安全的根源在于 HTTP 是明文传输。你在谷歌搜索了一个关键词（假设 Google 使用 HTTP），HTTP 数据包从你的计算机传送到服务器的过程中，中间经过的任意一个设备都可以轻松解析你的数据包，获取你的关键词，你的隐私毫无保障。</p>

<p>你的信息被人获取只是明文传输的其中一个问题。总体来说，明文传输有三个问题：</p>

<ul>
<li>窃听：第三方可以获取你的信息</li>
<li>篡改：第三方可以修改你的信息</li>
<li>冒充：第三方可以冒充你的身份</li>
</ul>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.09.05
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/08/20/use-dnsmasq-to-build-own-dns-server/">
          使用 Dnsmasq 搭建内网 DNS 服务器
        </a>

        <div class="index__item__content post__content">
          <p>在日常开发过程中，我们经常要配置各种
 host，比如公司内部的各种服务，或者测试项目的时候暂时把生产环境 URL 配置到本地上等等。一般采取的方法都是每个人手动编辑自己的 <code>/etc/hosts</code> 文件。这个做法有两个缺点：</p>

<ul>
<li>手动编辑 <code>/etc/hosts</code> 文件非常麻烦，需要 <code>sudo</code></li>
<li>工作量重复，团队内每个人都要配置一遍</li>
</ul>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.08.20
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/06/25/webpack-long-term-caching-101/">
          Webpack Long Term Caching 101
        </a>

        <div class="index__item__content post__content">
          <p>缓存是 Web 中无法回避的话题，不仅因为缓存非常重要，能极大地改善用户体验，而且因为缓存很难做好。一旦生产环境出现了缓存失效，那就是一个十分棘手的问题。</p>

<p>在各种缓存的方案中，基于 hash 的 Long Term Caching（永久缓存）在我看来是最简单也是最高效。每一个资源名称上都带有自身内容的 hash 值，然后全部设置为永久缓存永不过期。所有资源的索引文件全部设置为永不缓存。这样就保证了当资源更新时，资源名称会变化，索引文件会引入新的资源名称，也就保证了缓存永远不会失效。</p>

<p>这个处理方案显然和前端自身的编码没有关系，而是需要打包工具的支持。以下我们就用 webapck 为例，详细讲述怎样一步步实现 Long Term Caching。项目最终的仓库 <a href="https://github.com/fate-lovely/long-term-caching-demo.git">long-term-caching-demo</a>。</p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.06.25
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/05/21/ngrok-tutorial/">
          使用 Ngrok 实现内网穿透
        </a>

        <div class="index__item__content post__content">
          <p>很多时候，我们都有这样的需求：需要将本地正在开发的服务暴露在公网上，也就是从外网直接访问我们本机上的服务。正常情况下，这是办不到的，因为我们的本机并没有公网 IP，我们的本机处在内网当中。</p>

<p>这里需要顺手提及一个知识：NAT 穿透。我们的机器一般都在路由器的内网当中，IP 地址基本上都是 <code>192.168.x.x</code> 系列，我们并没有公网 IP，那么如何访问外网呢？我们打开浏览器访问 Google，Google 与我们主机之间如何通信？假设我们主机 IP 为 <code>192.168.0.100</code>，路由器 LAN IP 为 <code>192.168.0.1</code>，WAN IP 为 <code>211.22.145.234（这是一个公网IP）</code>，Google 服务器 IP 为 <code>74.125.204.101</code>，详细通信流程如下。</p>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.05.21
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/04/06/first-chrome-extension-image-bed-on-weibo/">
          编写第一个 Chrome 插件 —— 图床on微博
        </a>

        <div class="index__item__content post__content">
          <p>之前写博客需要的图片全部都是本地存储，非常麻烦。流程如下：先用截图工具截图（QQ 截图就很好用），然后移动到目标文件夹，然后在 Markdown 中输入绝对路径（Jekyll 生成站点以后路径会变化，所以不能使用相对路径）。除了麻烦以外，在 Markdown 中编写时还是看不到图的，因为路径不对。</p>

<p>上次花点时间把所有的图片全部迁移到微博图床了。在 Chrome Web Store 中搜索了一下，选了<a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-ntp-icon">新浪微博图床</a>。功能是可以用的，不过有一些问题，最让我无法忍受的就是一点击按钮就会弹出一个 Chrome 的空白窗口，无法关闭，只有重启 Chrome 才行，这个实在是忍无可忍。</p>

<p>闲话不说了，总之我发现这是一次绝佳的自己造轮子的机会。自己造自己用多好玩，所以我准备自己写一个 Chrome 插件，来实现微博图床的功能。起什么名字好呢，恩，这真是一个世界难题。想了半天，决定叫做“图床on微博”吧，是的，我是 RoR 粉丝。</p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.04.06
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/03/20/intruduction-to-functional-reactive-programming/">
          Functional Reactive Programming 简介
        </a>

        <div class="index__item__content post__content">
          <p>推荐阅读：</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=XRYN2xt11Ek">Netflix JavaScript Talks - Async JavaScript with Reactive Extensions</a></li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a></li>
</ul>

<p>HTML5Rocks 有一篇关于 <a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Promise</a> 的经典文章，通过引入这样一个问题来说明 Promise 的优越性，问题如下：</p>

<blockquote>
<p>我们需要渲染一个故事，首先我们获取故事的 json，渲染标题 (story.heading)，然后再根据其中的 charpter url，获取每一章的内容，并显示。中间出了任何问题，显示错误信息。</p>
</blockquote>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.03.20
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2016/01/17/javascript-infinite-currying/">
          JavaScript Infinite Currying
        </a>

        <div class="index__item__content post__content">
          <p>很久之前曾看到一个很有意思的 JS 问题，</p>

<pre><code class="language-javascript">// 定义一个函数 add，满足如下性质：
add(1) == 1
add(1)(2) == 3
add(1)(2)(3) == 6
...

var g = add(1)(2)
g(100) == 103
g(200) == 203
...
</code></pre>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.01.17
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/2015/09/24/frontend-development-with-browserify-sass-browsersync-gulp/">
          Browserify &#43; SASS &#43; BrowserSync &#43; Gulp 高效前端开发环境配置
        </a>

        <div class="index__item__content post__content">
          <p>之前开发的前端应用都是些比较简单的页面，开发的时候一般就是 Sublime，然后命令行里面启动 <code>sass --watch</code> 以及 <code>coffee --watch</code> 就行了，修改代码以后自动编译，但是浏览器需要手动刷新。凑合着也能用，所以也就一直这样没有去理会别的解决方案了。</p>

<p>工作了以后，编写的应用规模变大了很多，而且前端的依赖也变得复杂了。传统的方式显然是解决不了问题的。这段时间，我一直在寻找一套高效的开发环境，要求如下：</p>

<ul>
<li>使用 CommonJS 进行依赖引用</li>
<li>ES6 支持</li>
<li>React + JSX 支持</li>
<li>SASS 支持</li>
<li>修改以后自动高速编译，即便是很大的依赖</li>
<li>修改 JS、HTML 以后浏览器自动刷新</li>
<li>修改 CSS 浏览器使用 Style Injection 刷新</li>
<li>生产环境下合并压缩</li>
</ul>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2015.09.24
          </div>
        </div>
      </div>
    

    <div class="index__paginator">
      
        <a href="/">Prev</a>
      

      <div class="index__paginator__info">
        <span>2</span>
        /
        <span>3</span>
      </div>

      
        <a href="/page/3/">Next</a>
      
    </div>
  </div>

        </div>
      
    </main>
  

  <script src="/asset/main.js"></script>

  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4f34ee3c85734c8235badd2b99b092a6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>
</html>
