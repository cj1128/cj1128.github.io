<!doctype html>
<html lang="en">
<head>
	<meta name="generator" content="Hugo 0.41-DEV" />
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0">
  <title>CJ Ting&#39;s Blog - CJ Ting's Blog</title>
  <meta name="author" content="CJ Ting">
  <meta name="description" content="CJ Ting&#39;s Blog">
  <meta charset="utf-8" />
  <link rel="stylesheet" href="/asset/main.css">
  <link rel="stylesheet" type="text/css" href="/gitalk.css">
  <script src="/gitalk.min.js"></script>
  <script type="text/javascript">
    window.PAGE = {
      title: "CJ Ting\x27s Blog",
    }
  </script>
</head>
<body>
  
    <header class="header">
  <a href="/">
    <img class="header__avatar" src="/image/avatar.jpeg">
  </a>

  <nav class="header__nav">
    <a href="/" class="header__nav__item  header__nav__item--active ">Posts</a>

    <a href="/archive" class="header__nav__item ">Archive</a>

    <a href="https://github.com/fate-lovely" class="header__nav__item" target="_blank">Github</a>

    <a href="/about" class="header__nav__item">About</a>
  </nav>
</header>

    <main class="main">
      
        <nav class="sidebar">
  
  
    <a class="sidebar__item " href="/web2.0/">Web2.0</a>
  
    <a class="sidebar__item " href="/golang/">Golang</a>
  
    <a class="sidebar__item " href="/linux/">Linux</a>
  
    <a class="sidebar__item " href="/mac/">Mac</a>
  
    <a class="sidebar__item " href="/misc/">MISC</a>
  
</nav>

        <div class="container">
          
  <div class="index">
    
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/misc/build-log-system-with-elkb/">
          从零开始搭建一个ELKB日志收集系统
        </a>

        <div class="index__item__content post__content">
          <p>当今的软件开发<strong>多核</strong>以及<strong>分布</strong>已经成为了常态，基本上稍大型的应用都是多台机器分布式部署。分布式在提高性能的同时也带来了很多问题，今天我们只讨论一点，那就是如何处理多台机器线上系统的日志。</p>

<p>以我司的某个应用T为例，部署在了百度云5台机子上，其中一台拥有公网IP，使用了百度云提供的负载均衡服务。每次想要在日志中检索某个关键字时，基本步骤如下：</p>

<ul>
<li>打开五个shell，登陆拥有公网IP的那台机器</li>
<li>在另外四个shell中分别登陆其他的内网机器</li>
<li>对日志文件进行检索</li>
</ul>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.10.21
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/build-a-https-site-from-scratch/">
          从零开始搭建一个HTTPS网站
        </a>

        <div class="index__item__content post__content">
          <p>我们都知道HTTP是非常不安全的，不安全的根源在于HTTP是明文传输。你在谷歌搜索了一个关键词（假设Google使用HTTP），HTTP数据包从你的计算机传送到服务器的过程中，中间经过的任意一个设备都可以轻松解析你的数据包，获取你的关键词，你的隐私毫无保障。</p>

<p>你的信息被人获取只是明文传输的其中一个问题。总体来说，明文传输有三个问题：</p>

<ul>
<li>窃听：第三方可以获取你的信息。</li>
<li>篡改：第三方可以修改你的信息。</li>
<li>冒充：第三方可以冒充你的身份。</li>
</ul>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.09.05
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/misc/use-dnsmasq-to-build-own-dns-server/">
          使用Dnsmasq搭建内网DNS服务器
        </a>

        <div class="index__item__content post__content">
          <p>在日常开发过程中，我们经常要配置各种
host，比如公司内部的各种服务，或者测试项目的时候暂时把生产环境URL配置到本地上等等。一般采取的方法都是每个人手动编辑自己的<code>/etc/hosts</code>文件。这个做法有两个缺点：</p>

<ul>
<li>手动编辑<code>/etc/hosts</code>文件非常麻烦，需要<code>sudo</code></li>
<li>工作量重复，团队内每个人都要配置一遍</li>
</ul>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.08.20
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/webpack-long-term-caching-101/">
          Webpack Long Term Caching 101
        </a>

        <div class="index__item__content post__content">
          <p>缓存是Web中无法回避的话题，不仅因为缓存非常重要，能极大地改善用户体验，而且因为缓存很难做好。一旦生产环境出现了缓存失效，那就是一个十分棘手的问题。</p>

<p>在各种缓存的方案中，基于hash的Long Term Caching（永久缓存）在我看来是最简单也是最高效。每一个资源名称上都带有自身内容的hash值，然后全部设置为永久缓存永不过期。所有资源的索引文件全部设置为永不缓存。这样就保证了当资源更新时，资源名称会变化，索引文件会引入新的资源名称，也就保证了缓存永远不会失效。</p>

<p>这个处理方案显然和前端自身的编码没有关系，而是需要打包工具的支持。以下我们就用webapck为例，详细讲述怎样一步步实现Long Term Caching。项目最终的仓库<a href="https://github.com/fate-lovely/long-term-caching-demo.git">long-term-caching-demo</a>。</p>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.06.25
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/misc/ngrok-tutorial/">
          使用Ngrok实现内网穿透
        </a>

        <div class="index__item__content post__content">
          <p>很多时候，我们都有这样的需求：需要将本地正在开发的服务暴露在公网上，也就是从外网直接访问我们本机上的服务。正常情况下，这是办不到的，因为我们的本机并没有公网IP，我们的本机处在内网当中。</p>

<p>这里需要顺手提及一个知识：NAT穿透。我们的机器一般都在路由器的内网当中，IP地址基本上都是<code>192.168.x.x</code>系列，我们并没有公网IP，那么如何访问外网呢？我们打开浏览器访问Google，Google与我们主机之间如何通信？假设我们主机IP为<code>192.168.0.100</code>，路由器LAN IP为<code>192.168.0.1</code>，WAN IP为<code>211.22.145.234（这是一个公网IP）</code>，Google服务器IP为<code>74.125.204.101</code>。详细通信流程如下。</p>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2016.05.21
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/first-chrome-extension-image-bed-on-weibo/">
          编写第一个Chrome插件——图床on微博
        </a>

        <div class="index__item__content post__content">
          <p>之前写博客需要的图片全部都是本地存储，非常麻烦。流程如下：先用截图工具截图（QQ截图就很好用），然后移动到目标文件夹，然后在markdown中输入绝对路径（jekyll生成站点以后路径会变化，所以不能使用相对路径）。除了麻烦以外，在markdown中编写时还是看不到图的，因为路径不对。</p>

<p>上次花点时间把所有的图片全部迁移到微博图床了。在chrome web store中搜索了一下，选了<a href="https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf?utm_source=chrome-ntp-icon">新浪微博图床</a>。功能是可以用的，不过有一些问题，最让我无法忍受的就是一点击按钮就会弹出一个chrome的空白窗口，无法关闭，只有重启chrome才行，这个实在是忍无可忍。</p>

<p>闲话不说了，总之我发现这是一次绝佳的自己造轮子的机会。自己造自己用多好玩，所以我准备自己写一个chrome 插件，来实现微博图床的功能。起什么名字好呢，恩，这真是一个世界难题。想了半天，决定叫做“图床on微博”吧，是的，我是RoR粉丝。</p>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.04.06
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/intruduction-to-functional-reactive-programming/">
          Functional Reactive Programming 简介
        </a>

        <div class="index__item__content post__content">
          <p>推荐阅读：</p>

<ul>
<li><a href="https://www.youtube.com/watch?v=XRYN2xt11Ek">Netflix JavaScript Talks - Async JavaScript with Reactive Extensions</a></li>
<li><a href="https://gist.github.com/staltz/868e7e9bc2a7b8c1f754">The introduction to Reactive Programming you&rsquo;ve been missing</a></li>
</ul>

<p>HTML5Rocks有一篇关于<a href="http://www.html5rocks.com/en/tutorials/es6/promises/">Promise</a>的经典文章，通过引入这样一个问题来说明Promise的优越性。问题如下：</p>

<blockquote>
<p>我们需要渲染一个故事，首先我们获取故事的json，渲染标题(story.heading)，然后再根据其中的charpter url，获取每一章的内容，并显示。中间出了任何问题，显示错误信息。</p>
</blockquote>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.03.20
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/javascript-infinite-currying/">
          JavaScript Infinite Currying
        </a>

        <div class="index__item__content post__content">
          <p>很久之前曾看到一个很有意思的JS问题，</p>

<pre><code class="language-javascript">// 定义一个函数add，满足如下性质：
add(1) == 1
add(1)(2) == 3
add(1)(2)(3) == 6
...

var g = add(1)(2)
g(100) == 103
g(200) == 203
...
</code></pre>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2016.01.17
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/web2.0/frontend-development-with-browserify-sass-browsersync-gulp/">
          Browserify &#43; SASS &#43; BrowserSync &#43; Gulp高效前端开发环境配置
        </a>

        <div class="index__item__content post__content">
          <p>之前开发的前端应用都是些比较简单的页面，开发的时候一般就是sublime，然后命令行里面启动<code>sass --watch</code> 以及 <code>coffee --watch</code> 就行了，修改代码以后自动编译，但是浏览器需要手动刷新。凑合着也能用，所以也就一直这样没有去理会别的解决方案了。</p>

<p>工作了以后，编写的应用规模变大了很多，而且前端的依赖也变得复杂了。传统的方式显然是解决不了问题的。这段时间，我一直在寻找一套高效的开发环境，要求如下：</p>

<ul>
<li>使用CommonJS进行依赖引用</li>
<li>ES6支持</li>
<li>React + JSX支持</li>
<li>SASS支持</li>
<li>修改以后自动高速编译，即便是很大的依赖</li>
<li>修改JS、HTML以后浏览器自动刷新</li>
<li>修改CSS浏览器使用Style Injection刷新</li>
<li>生产环境下合并压缩</li>
</ul>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/web2.0/">
            web2.0
          </a>
          <div>
          </div>
          <div>
            2015.09.24
          </div>
        </div>
      </div>
    
      <div class="index__item">
        <a class="index__item__title hvr-underline-from-left" href="/misc/underhanded-c/">
          Underhanded C, 有猫腻的C
        </a>

        <div class="index__item__content post__content">
          <p>这一切，都要从这篇文章说起，<a href="http://www.codersnotes.com/notes/being-sneaky-in-c">being-sneaky-in-c</a>。</p>

<p>通过这篇文章，我了解到，原来外国有一种比赛，叫做Underhanded C（中文翻译：有猫腻的C），完成规定的题目，要求是写出看起来毫无问题的代码，但是却偷偷的藏有Bug或者说后门。</p>

<p>这篇文章说的就是作者参与了这个比赛，以及他的解决方案。</p>

<p></p>
        </div>

        <div class="index__item__meta">
          
          <a href="/misc/">
            misc
          </a>
          <div>
          </div>
          <div>
            2015.06.16
          </div>
        </div>
      </div>
    

    <div class="index__paginator">
      
        <a href="/">Prev</a>
      

      <div class="index__paginator__info">
        <span>2</span>
        /
        <span>3</span>
      </div>

      
        <a href="/page/3/">Next</a>
      
    </div>
  </div>

        </div>
      
    </main>
  

  <script src="/asset/main.js"></script>

  
  <script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?4f34ee3c85734c8235badd2b99b092a6";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
})();
</script>

</body>
</html>
